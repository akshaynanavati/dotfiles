# Show git branch in prompt
source ~/.git_prompt
source ~/.git_completion.sh
source ~/.fab_completion
source ~/.ssh_completion

# Returns "*" if the current git branch is dirty.
function parse_git_dirty {
  [[ $(git diff --shortstat 2> /dev/null | tail -n1) != "" ]] && echo "*"
}

# Returns "|shashed:N" where N is the number of stashed states (if any).
function parse_git_stash {
  local stash=`expr $(git stash list 2>/dev/null| wc -l)`
  if [ "$stash" != "0" ]
  then
    echo "|stashed:$stash"
  fi
}

###Change the terminal prompt
PS1="\`if [ \$? = 0 ]; then echo \[\e[32m\]^_^\[\e[0m\]; else echo \[\e[31m\]O_O\[\e[0m\]; fi\`\[\e[0;36m [\T] \[\e[0m\]\[\e[0;34m(\$(__git_ps1)\$(parse_git_dirty)\$(parse_git_stash))\[\e[0m\]\n(\[\e[33m\]\u\[\e[0m\]:\[\e[32m\]\W\[\e[0m\])\$ "

export CLICOLOR=1
export LSCOLORS=gxBxhxDxfxhxhxhxhxcxcx

export EDITOR=vim

# Unix aliases
alias ll="ls -ltpG"
alias la="ls -ltapG"
alias lr="ls -altrpG"
alias kd='killall Dock'
alias kc='killall ControlStrip'
grepr() {
  if [ "$#" -eq 1 ]; then
    grep -r $1 .;
  elif [ "$#" -eq 2 ]; then
    grep -r $1 $2;
  elif [ "$#" -ge 2 ]; then
    grep -r "${@:3}" $1 $2;
  else
    echo 'Usage: grepr <search-string>[ <dir>[ <additional args>]]'
  fi
}
function getpids() { ps aux | grep $1 | awk '{ print $2 }'; }
function killregex() { kill -9 `getpids $1`; }
function mkcd () { mkdir -p "$@" && eval cd "\"\$$#\""; }

# git aliases
alias gashd='git stash drop'
alias gbr='g br'
alias gcob='gco -b'
alias glg='git log --graph'
alias gln='git log --stat --graph'
alias glno='git log --name-only'
alias gr='git reset --'
alias grh='git reset --hard'
alias grs='git reset --soft'
alias grv='git remote -v'
gnf () { gcob $1 && git fetch && git reset --hard origin/master; }
gcpl () { gco $1 && git pull; }

bind "set completion-ignore-case on"
bind "set show-all-if-ambiguous on"

export SUBL_DIR="$HOME/Library/Application Support/Sublime Text 3/"
export PATH="$PATH:$HOME/bin"
